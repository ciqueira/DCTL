#line 2 // Fix line numbers in resolve/logs/rollinglog.txt





// 6 hue, 1 wrap, 2 anchor.
#define N_POINTS 9
#define NORM_MULTS make_float3(2.0f * PI_LOCAL, _sqrtf(2.0f), 1.0f)
#define PI 3.1415926535897932384626
#define D65_xyY make_float3( 0.3127, 0.329, 1.0)

__CONSTANT__ float PI_LOCAL = 3.141592653589f;

#define catd65 make_float3(1.07046f, 0.916817f, 0.594251f)
// Gamut conversion Matrices
#define identity_mtx make_float3x3(make_float3(1.0f, 0.0f, 0.0f), make_float3(0.0f, 1.0f, 0.0f), make_float3(0.0f, 0.0f, 1.0f))
#define matrix_ap0_to_xyz make_float3x3(make_float3(0.950362384319f, 0.000000000000f, 0.000093463248f), make_float3(0.343966454268f, 0.728166162968f, -0.072132542729f), make_float3(0.000000000000f, 0.000000000000, 1.089057803154f))
#define matrix_ap1_to_xyz make_float3x3(make_float3(0.660931229591f, 0.133696138859f, 0.155828580260f), make_float3(0.272228747606f, 0.674081742764f, 0.053689509630f), make_float3(-0.006018006243f, 0.004383686464, 1.090692043304f))
#define matrix_p3d65_to_xyz make_float3x3(make_float3(0.486571133137f, 0.265667706728f, 0.198217317462f), make_float3(0.228974640369f, 0.691738605499f, 0.079286918044f), make_float3(-0.000000000000f, 0.045113388449, 1.043944478035f))
#define matrix_p3d60_to_xyz make_float3x3(make_float3(0.504949748516f, 0.264681518078f, 0.183015048504f), make_float3(0.237623393536f, 0.689170777798f, 0.073206014931f), make_float3(-0.000000000000f, 0.044945921749f, 0.963879227638f))
#define matrix_p3dci_to_xyz make_float3x3(make_float3(0.445170015097f, 0.277134418488f, 0.172282665968f), make_float3(0.209491759539f, 0.721595287323f, 0.068913064897f), make_float3(-0.000000000000f, 0.047060567886f, 0.907355427742f))
#define matrix_rec2020_to_xyz make_float3x3(make_float3(0.636958122253f, 0.144616916776f, 0.168880969286f), make_float3(0.262700229883f, 0.677998125553f, 0.059301715344f), make_float3(0.000000000000f, 0.028072696179, 1.060985088348f))
#define matrix_rec709_to_xyz make_float3x3(make_float3(0.412390917540f, 0.357584357262f, 0.180480793118f), make_float3(0.212639078498f, 0.715168714523f, 0.072192311287f), make_float3(0.019330825657f, 0.119194783270f, 0.950532138348f))
#define matrix_arriwg_to_xyz make_float3x3(make_float3(0.638007640839f, 0.214703813195f, 0.097744457424f), make_float3(0.291953772306f, 0.823840856552f, -0.115794822574f), make_float3(0.002798279049f, -0.067034222186, 1.153293848038f))
#define matrix_redwg_to_xyz make_float3x3(make_float3(0.735275208950f, 0.068609409034f, 0.146571278572f), make_float3(0.286694079638f, 0.842979073524f, -0.129673242569f), make_float3(-0.079680845141f, -0.347343206406, 1.516081929207f))
#define matrix_sonysgamut3 make_float3x3(make_float3(0.599083900452f, 0.248925492167f, 0.102446496487f), make_float3(0.215075820684f, 0.885068416595f, -0.100144319236f), make_float3(-0.032065849751f, -0.027658388019, 1.148782014847f))
#define matrix_egamut_to_xyz make_float3x3(make_float3(0.705396831036f, 0.164041340351f, 0.081017754972f), make_float3(0.280130714178f, 0.820206701756f, -0.100337378681f), make_float3(-0.103781513870f, -0.072907261550, 1.265746593475f))
#define matrix_davinciwg_to_xyz make_float3x3(make_float3(0.700622320175f, 0.148774802685f, 0.101058728993f), make_float3(0.274118483067f, 0.873631775379f, -0.147750422359f), make_float3(-0.098962903023f, -0.137895315886, 1.325916051865f))
#define matrix_blackmagicwg_to_xyz make_float3x3(make_float3(0.606538414955f, 0.220412746072f, 0.123504832387f), make_float3(0.267992943525f, 0.832748472691f, -0.100741356611f), make_float3(-0.029442556202f, -0.086612440646, 1.205112814903f))

/* Matrix for conversion from CIE 1931 XYZ tristumulus to CIE 2006 LMS or "Truelight LMS", described in:
    "Chromaticity Coordinates for Graphic Arts Based on CIE 2006 LMS with Even Spacing of Munsell Colours" by Richard Kirk
    https://doi.org/10.2352/issn.2169-2629.2019.27.38
*/
#define matrix_xyz_to_truelightlms make_float3x3(make_float3(0.257085f, 0.859943f, -0.031061f), make_float3(-0.394427, 1.175800f, 0.106423f), make_float3(0.064856f, -0.07625f, 0.559067f))

#define matrix_jzazbz_xyz_to_lms make_float3x3(make_float3(0.41479f, 0.579999f, 0.014648f), make_float3(-0.20151f, 1.12065f, 0.0531008f), make_float3(-0.0166008f, 0.2648f, 0.66848f))
#define matrix_jzazbz_lms_p_to_izazbz make_float3x3(make_float3(0.5f, 0.5f, 0.0f), make_float3(3.524f, -4.06671f, 0.542708f), make_float3(0.199076f, 1.0968f, -1.29588f))



// ----------------------------------------------------------

__DEVICE__ inline float spow(float x, float p) {
    if (x < 0.0f) {
        return -_powf(-x, p);
    }
    return _powf(x, p);
}

__DEVICE__ float interp_linear(__PRIVATE__ float2 *pts, int n_pts, float x) {
    if (x <= pts[0].x) {
        return pts[0].y;
    }

    if (x >= pts[n_pts - 1].x) {
        return pts[n_pts - 1].y;
    }

    int i = 0;
    int upper = n_pts - 1;
    while (i != upper - 1) {
        int m = i + (upper - i) / 2;
        if (x >= pts[m].x) {
            i = m;
        } else {
            upper = m;
        }
    }

    float t = (x - pts[i].x) / (pts[i + 1].x - pts[i].x);
    return _mix(pts[i].y, pts[i + 1].y, t);
}

// Custom 3x3 matrix struct float3x3
typedef struct {
  float3 x, y, z;
} float3x3;


// Helper function to create a float3x3
__DEVICE__ float3x3 make_float3x3(float3 a, float3 b, float3 c) {
  float3x3 d;
  d.x = a, d.y = b, d.z = c;
  return d;
}

// Multiply float3 vector a and 3x3 matrix m
__DEVICE__ float3 mult_f3_f33(float3 a, float3x3 m) {
  return make_float3(
    m.x.x * a.x + m.x.y * a.y + m.x.z * a.z,
    m.y.x * a.x + m.y.y * a.y + m.y.z * a.z,
    m.z.x * a.x + m.z.y * a.y + m.z.z * a.z);
}

// Calculate inverse of 3x3 matrix: https://stackoverflow.com/questions/983999/simple-3x3-matrix-inverse-code-c
__DEVICE__ float3x3 inv_f33(float3x3 m) {
  float d = m.x.x * (m.y.y * m.z.z - m.z.y * m.y.z) -
            m.x.y * (m.y.x * m.z.z - m.y.z * m.z.x) +
            m.x.z * (m.y.x * m.z.y - m.y.y * m.z.x);
  float id = 1.0f / d;
  float3x3 c = identity_mtx;
  c.x.x = id * (m.y.y * m.z.z - m.z.y * m.y.z);
  c.x.y = id * (m.x.z * m.z.y - m.x.y * m.z.z);
  c.x.z = id * (m.x.y * m.y.z - m.x.z * m.y.y);
  c.y.x = id * (m.y.z * m.z.x - m.y.x * m.z.z);
  c.y.y = id * (m.x.x * m.z.z - m.x.z * m.z.x);
  c.y.z = id * (m.y.x * m.x.z - m.x.x * m.y.z);
  c.z.x = id * (m.y.x * m.z.y - m.z.x * m.y.y);
  c.z.y = id * (m.z.x * m.x.y - m.x.x * m.z.y);
  c.z.z = id * (m.x.x * m.y.y - m.y.x * m.x.y);
  return c;
}

 __DEVICE__ float mod(float x, float y) {
     if (x < 0) {
         return y + _fmod(x, y);
     } else {
         return _fmod(x, y);
     }
}

__DEVICE__ float spowf(float base, float exp)
{
    return _copysignf(_powf(_fabs(base), exp), base);
}

__DEVICE__ float3 mv_33_3(float mat[3][3], float3 v) {
    float3 out = make_float3(mat[0][0] * v.x + mat[0][1] * v.y + mat[0][2] * v.z,
                            mat[1][0] * v.x + mat[1][1] * v.y + mat[1][2] * v.z,
                            mat[2][0] * v.x + mat[2][1] * v.y + mat[2][2] * v.z);
    return out;
}
 
__DEVICE__ float3 v_x_mtx_4x4(float3 v, float mtx[4][4])
{
    float4 v_h = make_float4(v.x, v.y, v.z, 1.0f);
    float4 out = make_float4(mtx[0][0] * v_h.x + mtx[0][1] * v_h.y + mtx[0][2] * v_h.z + mtx[0][3] * v_h.w,
                                mtx[1][0] * v_h.x + mtx[1][1] * v_h.y + mtx[1][2] * v_h.z + mtx[1][3] * v_h.w,
                                mtx[2][0] * v_h.x + mtx[2][1] * v_h.y + mtx[2][2] * v_h.z + mtx[2][3] * v_h.w,
                                mtx[3][0] * v_h.x + mtx[3][1] * v_h.y + mtx[3][2] * v_h.z + mtx[3][3] * v_h.w);
    out /= out.w;
    float3 out_n = make_float3(out.x, out.y, out.z);
    return out_n;
}

__DEVICE__ float normalize_gain(float3 in) {

    float3 out = in;

    float chroma = in.y;
    float angle = (in.x)*2*PI;
    angle = angle - PI/6;

    chroma = chroma*_atan2f(_sqrtf(2.0f),1.0f);
    out.y = _tanf(chroma)/_sqrtf(2.0f);
    float chroma_gain = 1/(2*_cosf((_acosf(_sinf(3*(angle))))/3));

    return chroma_gain;
}

__DEVICE__ float cbrtf(float x, float cube_root) {

    if (x < 0.0f){
    x = _fabs(x);
    cube_root = _powf(x, 1.0f/3.0f)*(-1.0f);
    } else cube_root = _powf(x, 1.0f/3.0f);

    return cube_root;
}

// ----------------------------------------------------------





// Color Models
__DEVICE__ float3 RGB_to_HSL(float3 RGB) {
    float R = RGB.x;
    float G = RGB.y;
    float B = RGB.z;
    
    float maxVal = _fmaxf(_fmaxf(R, G), B);
    float minVal = _fminf(_fminf(R, G), B);
    float delta = maxVal - minVal;
    
    // Calculate Lightness
    float L = (maxVal + minVal) * 0.5f;
    
    // Initialize Hue and Saturation
    float H = 0.0f;
    float S = 0.0f;
    
    // Only calculate Saturation and Hue if there's a difference between max and min values
    if (delta > 0.0f) {
        // Calculate Saturation
        S = delta / (1.0f - _fabs(2.0f * L - 1.0f));
        
        // Calculate Hue
        if (maxVal == R) {
            H = (G - B) / delta;
            if (H < 0.0f) H += 6.0f;
        } else if (maxVal == G) {
            H = ((B - R) / delta) + 2.0f;
        } else { // maxVal == B
            H = ((R - G) / delta) + 4.0f;
        }
        H /= 6.0f; // Normalize to [0,1] range
    }
    
    return make_float3(H, S, L);
}

__DEVICE__ float3 HSL_to_RGB(float3 HSL) {
    float H = HSL.x;
    float S = HSL.y;
    float L = HSL.z;
    
    // Early return for grayscale
    if (S <= 0.0f) {
        return make_float3(L, L, L);
    }
    
    float C = (1.0f - _fabs(2.0f * L - 1.0f)) * S;
    float H6 = H * 6.0f;
    float X = C * (1.0f - _fabs(_fmod(H6, 2.0f) - 1.0f));
    float m = L - C * 0.5f;
    
    float3 RGB;
    if (H6 < 1.0f)      RGB = make_float3(C, X, 0.0f);
    else if (H6 < 2.0f) RGB = make_float3(X, C, 0.0f);
    else if (H6 < 3.0f) RGB = make_float3(0.0f, C, X);
    else if (H6 < 4.0f) RGB = make_float3(0.0f, X, C);
    else if (H6 < 5.0f) RGB = make_float3(X, 0.0f, C);
    else                RGB = make_float3(C, 0.0f, X);
    
    return RGB + m;
}

__DEVICE__ float3 RGB_to_CHEN(float3 in) {
    float r = in.x;
    float g = in.y;
    float b = in.z;

    float h;
    float c;
    float l;

    const float rtr = r * 0.81649658f + g * -0.40824829f + b * -0.40824829f;
    const float rtg = r * 0.0f + g * 0.70710678f + b * -0.70710678f;
    const float rtb = r * 0.57735027f + g * 0.57735027f + b * 0.57735027f;

    const float art = _atan2f(rtg, rtr);

    const float sphr = _sqrtf(rtr*rtr + rtg*rtg + rtb*rtb);
    const float spht = art < 0.0f ? art + 2.0f * 3.141592653589f : art;
    const float sphp = _atan2f(_sqrtf(rtr*rtr + rtg*rtg), rtb);

    l = sphr * 0.5773502691896258f;
    h = spht * 0.15915494309189535f;
    c = sphp * 1.0467733744265997f;

    return make_float3(h, c, l);
}
   
__DEVICE__ float3 CHEN_to_RGB(float3 in) {
    float h = in.x * 6.283185307179586f;
    float c = in.y * 0.9553166181245093f;
    float l = in.z * 1.7320508075688772f;
    
   float r = 0;
   float g = 0;
   float b = 0;

    const float ctr = l * _sinf(c) * _cosf(h);
    const float ctg = l * _sinf(c) * _sinf(h);
    const float ctb = l * _cosf(c);

    r = ctr * 0.81649658f + ctg * 0.0f + ctb * 0.57735027f;
    g = ctr * -0.40824829f + ctg * 0.70710678f + ctb * 0.57735027f;
    b = ctr * -0.40824829f + ctg * -0.70710678f + ctb * 0.57735027f;

    return make_float3(r, g, b);
}


__DEVICE__ float3 RGB_to_Reuleaux(float3 rgb) {
    float3 rot = {
        _sqrtf(2.0f)/6.0f * (2.0f*rgb.x - rgb.y - rgb.z),
        (rgb.y - rgb.z) / _sqrtf(6.0f),
        (rgb.x + rgb.y + rgb.z) / 3.0f
    };

    float3 reuleaux = {
        PI_LOCAL - _atan2f(rot.y, -rot.x),
        rot.z == 0.0f ? 0.0f : _hypotf(rot.x, rot.y) / rot.z,
        max3(rgb.x, rgb.y, rgb.z)
    };

    return reuleaux / NORM_MULTS;
}

__DEVICE__ float3 Reuleaux_to_RGB(float3 reuleaux) {
    reuleaux *= NORM_MULTS;

    float m = NORM_MULTS.y
        * max3(
            _cosf(reuleaux.x),
            _cosf(reuleaux.x + NORM_MULTS.x / 3.0f),
            _cosf(reuleaux.x - NORM_MULTS.x / 3.0f)
        )
        + 1.0f / reuleaux.y;

    float3 ocs = {
        reuleaux.z * _cosf(reuleaux.x) / m,
        reuleaux.z * _sinf(reuleaux.x) / m,
        reuleaux.z
    };

    float3 rgb = {
        ocs.z - _sqrtf(3.0f / 2.0f) * _fmaxf(_fabs(ocs.y) - _sqrtf(3.0f) * ocs.x, 0.0f),
        ocs.z - _sqrtf(3.0f / 2.0f) * (_fmaxf(_fabs(ocs.y), _sqrtf(3.0f) * ocs.x) - ocs.y),
        ocs.z - _sqrtf(3.0f / 2.0f) * (_fmaxf(_fabs(ocs.y), _sqrtf(3.0f) * ocs.x) + ocs.y)
    };

    return rgb;
}
 
__DEVICE__ float3 Cylindrical_to_Rgb(float3 hsv) {
    // Adapted from Juan Pablo Zambrano's code
    float3 lsh = make_float3(hsv.z, hsv.y * 3.0, mod(hsv.x, 1.0) * 2.0 * PI);

    float ctr = lsh.x * lsh.y * _cosf(lsh.z);
    float ctg = lsh.x;
    float ctb = lsh.x * lsh.y * _sinf(lsh.z);
    float3 c = make_float3(ctr, ctg, ctb);

    float mat[3][3] = {
        {2.0 / 3.0, 1.0, 0.0},
        {-1.0 / 3.0, 1.0, _sqrtf(3.0) / 3.0},
        {-1.0 / 3.0, 1.0, -_sqrtf(3.0) / 3.0},
    };

    return mv_33_3(mat, c);
}
 
__DEVICE__ float3 RGB_to_Cylindrical(float3 x) {

    // Matrix aligns and scales achromatic white (1, 1, 1) with (0, 1, 0)
    // Also rotates input (1, 0, 0) above the red axis and ensures that
    // (1, 0, 0) input ends up having a red channel code value of (1).
    float mat[3][3] = {
        {1.0, -1.0 / 2.0, -1.0 / 2.0},
        {1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0},
        {0.0, _sqrtf(3.0) / 2.0, -_sqrtf(3.0) / 2.0},
    };

    float3 rotated_color = mv_33_3(mat, x);
    float l = rotated_color.y;
    float3 hsl = make_float3(0.0, 0.0, 0.0);

    float3 normalized_color = rotated_color / l;
    if (l == 0.0) {
        hsl = make_float3(0.0, 0.0, l);
    } else {
        float theta = _atan2f(normalized_color.z, normalized_color.x);
        hsl.x = mod(theta, 2.0 * PI) / (2.0 * PI);
        hsl.y = _hypotf(normalized_color.x, normalized_color.z) / 3.0;
        hsl.z = l;
    }
    return hsl;
}

__DEVICE__ float3 RGB_to_HSV(float3 RGB) {
    float R = RGB.x, G = RGB.y, B = RGB.z;
    float maxVal = _fmaxf(R, _fmaxf(G, B));
    float minVal = _fminf(R, _fminf(G, B));
    float delta = maxVal - minVal;

    float H = 0.0, S = (maxVal == 0.0) ? 0.0 : delta / maxVal;
    float V = maxVal;

    if (delta != 0.0) {
        if (maxVal == R) {
            H = mod(((G - B) / delta), 6.0);
        } else if (maxVal == G) {
            H = ((B - R) / delta) + 2.0;
        } else {
            H = ((R - G) / delta) + 4.0;
        }
        H /= 6.0;
        if (H < 0.0) H += 1.0;
    }

    return make_float3(H, S, V);
}
 
__DEVICE__ float3 HSV_to_RGB(float3 HSV) {
    float H = HSV.x * 6.0; // Scale hue to [0, 6]
    float S = HSV.y;
    float V = HSV.z;

    float C = V * S; // Chroma
    float X = C * (1.0 - _fabs(mod(H, 2.0) - 1.0)); // Second largest component
    float m = V - C;

    float3 RGB;
    if      (H < 1.0) RGB = make_float3(C, X, 0);
    else if (H < 2.0) RGB = make_float3(X, C, 0);
    else if (H < 3.0) RGB = make_float3(0, C, X);
    else if (H < 4.0) RGB = make_float3(0, X, C);
    else if (H < 5.0) RGB = make_float3(X, 0, C);
    else              RGB = make_float3(C, 0, X);

    return RGB + m;
}

 // Convert HSP (Hue, Saturation, Perceived brightness) to RGB
__DEVICE__ float3 HSP_to_RGB(float3 hsp) {
    // Constants for the HSP-RGB conversion
    const float Pr = 0.299f;
    const float Pg = 0.587f;
    const float Pb = 0.114f;
    float H = hsp.x;
    float S = hsp.y;
    float P = hsp.z;

    float3 rgb;
    float minOverMax = 1.0f - S;
    float part;

    if (minOverMax > 0.0f) {
        if (H < 1.0f / 6.0f) {  // R > G > B
            H = 6.0f * H;
            part = 1.0f + H * (1.0f / minOverMax - 1.0f);
            rgb.z = P / _sqrtf(Pr / (minOverMax * minOverMax) + Pg * part * part + Pb);
            rgb.x = rgb.z / minOverMax;
            rgb.y = rgb.z + H * (rgb.x - rgb.z);
        } else if (H < 2.0f / 6.0f) {  // G > R > B
            H = 6.0f * (2.0f / 6.0f - H);
            part = 1.0f + H * (1.0f / minOverMax - 1.0f);
            rgb.z = P / _sqrtf(Pg / (minOverMax * minOverMax) + Pr * part * part + Pb);
            rgb.y = rgb.z / minOverMax;
            rgb.x = rgb.z + H * (rgb.y - rgb.z);
        } else if (H < 3.0f / 6.0f) {  // G > B > R
            H = 6.0f * (H - 2.0f / 6.0f);
            part = 1.0f + H * (1.0f / minOverMax - 1.0f);
            rgb.x = P / _sqrtf(Pg / (minOverMax * minOverMax) + Pb * part * part + Pr);
            rgb.y = rgb.x / minOverMax;
            rgb.z = rgb.x + H * (rgb.y - rgb.x);
        } else if (H < 4.0f / 6.0f) {  // B > G > R
            H = 6.0f * (4.0f / 6.0f - H);
            part = 1.0f + H * (1.0f / minOverMax - 1.0f);
            rgb.x = P / _sqrtf(Pb / (minOverMax * minOverMax) + Pg * part * part + Pr);
            rgb.z = rgb.x / minOverMax;
            rgb.y = rgb.x + H * (rgb.z - rgb.x);
        } else if (H < 5.0f / 6.0f) {  // B > R > G
            H = 6.0f * (H - 4.0f / 6.0f);
            part = 1.0f + H * (1.0f / minOverMax - 1.0f);
            rgb.y = P / _sqrtf(Pb / (minOverMax * minOverMax) + Pr * part * part + Pg);
            rgb.z = rgb.y / minOverMax;
            rgb.x = rgb.y + H * (rgb.z - rgb.y);
        } else {  // R > B > G
            H = 6.0f * (6.0f / 6.0f - H);
            part = 1.0f + H * (1.0f / minOverMax - 1.0f);
            rgb.y = P / _sqrtf(Pr / (minOverMax * minOverMax) + Pb * part * part + Pg);
            rgb.x = rgb.y / minOverMax;
            rgb.z = rgb.y + H * (rgb.x - rgb.y);
        }
    } else {
        // Handle grayscale case when minOverMax == 0
        if (H < 1.0f / 6.0f) {  // R > G > B
            H = 6.0f * H;
            rgb.x = _sqrtf(P * P / (Pr + Pg * H * H));
            rgb.y = rgb.x * H;
            rgb.z = 0.0f;
        } else if (H < 2.0f / 6.0f) {  // G > R > B
            H = 6.0f * (2.0f / 6.0f - H);
            rgb.y = _sqrtf(P * P / (Pg + Pr * H * H));
            rgb.x = rgb.y * H;
            rgb.z = 0.0f;
        } else if (H < 3.0f / 6.0f) {  // G > B > R
            H = 6.0f * (H - 2.0f / 6.0f);
            rgb.y = _sqrtf(P * P / (Pg + Pb * H * H));
            rgb.z = rgb.y * H;
            rgb.x = 0.0f;
        } else if (H < 4.0f / 6.0f) {  // B > G > R
            H = 6.0f * (4.0f / 6.0f - H);
            rgb.z = _sqrtf(P * P / (Pb + Pg * H * H));
            rgb.y = rgb.z * H;
            rgb.x = 0.0f;
        } else if (H < 5.0f / 6.0f) {  // B > R > G
            H = 6.0f * (H - 4.0f / 6.0f);
            rgb.z = _sqrtf(P * P / (Pb + Pr * H * H));
            rgb.x = rgb.z * H;
            rgb.y = 0.0f;
        } else {  // R > B > G
            H = 6.0f * (6.0f / 6.0f - H);
            rgb.x = _sqrtf(P * P / (Pr + Pb * H * H));
            rgb.z = rgb.x * H;
            rgb.y = 0.0f;
        }
    }

    return rgb;
}
 
// Convert RGB to HSP (Perceived Brightness, Hue, Saturation)
__DEVICE__ float3 RGB_to_HSP(float3 rgb) {
    // Constants for the HSP-RGB conversion
    const float Pr = 0.299f;
    const float Pg = 0.587f;
    const float Pb = 0.114f;
    float R = rgb.x;
    float G = rgb.y;
    float B = rgb.z;

    float3 hsp;
    float P = _sqrtf(R * R * Pr + G * G * Pg + B * B * Pb);  // Perceived brightness
    hsp.z = P;

    // Calculate Hue and Saturation
    if (R == G && R == B) {  // Grayscale, no hue or saturation
        hsp.x = 0.0f; // Hue
        hsp.y = 0.0f; // Saturation
        return hsp;
    }

    if (R >= G && R >= B) {  // R is largest
        if (B >= G) {
            hsp.x = 1.0f - (B - G) / (6.0f * (R - G)); // Hue
            hsp.y = 1.0f - G / R;                     // Saturation
        } else {
            hsp.x = (G - B) / (6.0f * (R - B));       // Hue
            hsp.y = 1.0f - B / R;                     // Saturation
        }
    } else if (G >= R && G >= B) {  // G is largest
        if (R >= B) {
            hsp.x = (2.0f / 6.0f) - (R - B) / (6.0f * (G - B)); // Hue
            hsp.y = 1.0f - B / G;                               // Saturation
        } else {
            hsp.x = (2.0f / 6.0f) + (B - R) / (6.0f * (G - R)); // Hue
            hsp.y = 1.0f - R / G;                               // Saturation
        }
    } else {  // B is largest
        if (G >= R) {
            hsp.x = (4.0f / 6.0f) - (G - R) / (6.0f * (B - R)); // Hue
            hsp.y = 1.0f - R / B;                               // Saturation
        } else {
            hsp.x = (4.0f / 6.0f) + (R - G) / (6.0f * (B - G)); // Hue
            hsp.y = 1.0f - G / B;                               // Saturation
        }
    }

    return hsp;
}
 
__DEVICE__ float3 XYZ_to_xyY(float3 XYZ) {
    float3 xyY;
    float divisor = (_fabs(XYZ.x) + _fabs(XYZ.y) + _fabs(XYZ.z));
    if (divisor == 0.0f) divisor = 1e-10f;
    xyY.x =_fabs(XYZ.x) / divisor;
    xyY.y = _fabs(XYZ.y)/ divisor;
    xyY.z = _fabs(XYZ.y);
    return xyY;
}
 
__DEVICE__ float3 xyY_to_XYZ(float3 xyY) {
    float3 XYZ;
    XYZ.x = xyY.x * xyY.z / _fmaxf( xyY.y, 1e-10f);
    XYZ.y = xyY.z;
    XYZ.z = (1.0f - xyY.x - xyY.y) * xyY.z / _fmaxf( xyY.y, 1e-10f);
    return XYZ;
}
 
__DEVICE__ float3 XYZ_to_CIELab(float3 XYZ, float offset, float scale) {
    float Xr = 95.047f;
    float Yr = 100.0f;
    float Zr = 108.883f;
    float E = 216.0f / 24389.0f;
    float K = 24389.0f / 27.0f;

    // XYZ to Lab
    float xr = 100.0f * XYZ.x / Xr;
    float yr = 100.0f * XYZ.y / Yr;
    float zr = 100.0f * XYZ.z / Zr;

    float fx = xr > E ? spowf(xr, 1.0f / 3.0f) : (K * xr + 16.0f) / 116.0f;
    float fy = yr > E ? spowf(yr, 1.0f / 3.0f) : (K * yr + 16.0f) / 116.0f;
    float fz = zr > E ? spowf(zr, 1.0f / 3.0f) : (K * zr + 16.0f) / 116.0f;

    float L = 116.0f * fy - 16.0f;
    float a = 500.0f * (fx - fy);
    float b = 200.0f * (fy - fz);

    // scaling and offset
    L = L * .01f;
    a = a * .01f * .25f * scale + offset;
    b = b * .01f * .25f * scale + offset;

    return make_float3(L, a, b);
}
 
__DEVICE__ float3 CIELab_to_XYZ(float3 Lab, float offset, float scale) {
    float Xr = 95.047f;
    float Yr = 100.0f;
    float Zr = 108.883f;
    float E = 216.0f / 24389.0f;
    float K = 24389.0f / 27.0f;

    float L = Lab.x, a = Lab.y, b = Lab.z;

    // scaling and offset
    L = L * 100.0f;
    a = (a - offset) * 4.0f / scale * 100.0f;
    b = (b - offset) * 4.0f / scale * 100.0f;

    // Lab to XYZ
    float fy = (L + 16.0f) / 116.0f;
    float fx = a / 500.0f + fy;
    float fz = fy - b / 200.0f;

    float xr = spowf(fx, 3.0f) > E ? spowf(fx, 3.0f) : (116.0f * fx - 16.0f) / K;
    float yr = L > (K * E) ? spowf((L + 16.0f) / 116.0f, 3.0f) : L / K;
    float zr = spowf(fz, 3.0f) > E ? spowf(fz, 3.0f) : (116.0f * fz - 16.0f) / K;

    float X = xr * Xr / 100.0f;
    float Y = yr * Yr / 100.0f;
    float Z = zr * Zr / 100.0f;

    return make_float3(X, Y, Z);
}
  
__DEVICE__ float3 XYZ_to_ProLab(float3 XYZ, float offset, float scale) {
    float3 XYZ_n = xyY_to_XYZ(D65_xyY);

    float MATRIX_Q[4][4] = {{  75.54f,  486.66f,  167.39f, 0.0f},
                            { 617.72f, -595.45f,  -22.27f, 0.0f},
                            {  48.34f,  194.94f, -243.28f, 0.0f},
                            { 0.7554f,  3.8666f,  1.6739f, 1.0f}};

    XYZ *= 1.0 / XYZ_n;

    float3 Lab = v_x_mtx_4x4(XYZ, MATRIX_Q);

    Lab *= 0.01f;

    Lab.y = Lab.y * 0.5f * scale + offset;
    Lab.z = Lab.z * 0.5f * scale + offset;

    return Lab;
}
  
__DEVICE__ float3 ProLab_to_XYZ(float3 Lab, float offset, float scale) {
    float3 XYZ_n = xyY_to_XYZ(D65_xyY);

    float MATRIX_INVERSE_Q[4][4] = {{ 0.0013706f,  0.0013874f,  0.0008161f, 0.0f},
                                    { 0.0013706f, -0.0002432f,  0.0009653f, 0.0f},
                                    { 0.0013706f,  0.0000808f, -0.0031748f, 0.0f},
                                    {-0.0086294f, -0.0002432f,  0.0009653f, 1.0f}};

    Lab.y = (Lab.y - offset) * 2.0f / scale;
    Lab.z = (Lab.z - offset) * 2.0f / scale;

    Lab *= 100.0f;

    float3 XYZ = v_x_mtx_4x4(Lab, MATRIX_INVERSE_Q);

    XYZ *= XYZ_n;

    return XYZ;
}
  
__DEVICE__ float3 Lab_to_LCH(float3 Lab) {
    float3 LCH;
    LCH.x = Lab.x;
    LCH.y = _sqrtf(Lab.y * Lab.y + Lab.z * Lab.z);
    LCH.z = _atan2f(Lab.z, Lab.y) * 180.0f / PI;
    LCH.z = LCH.z < 0.0f ? LCH.z + 360.0f : LCH.z;

    LCH.z /= 360.0f;

    return LCH;
}
  
__DEVICE__ float3 LCH_to_Lab(float3 LCH) {
    LCH.z *= 360.0f;

    float3 Lab;
    Lab.x = LCH.x;
    Lab.y = LCH.y * _cosf(LCH.z * PI / 180.0f);
    Lab.z = LCH.y * _sinf(LCH.z * PI / 180.0f);

    return Lab;
}

__DEVICE__ float3 RGB_to_Spherical(float3 x) {
    
    float3 in = x;
    float norm = _fmaxf(in.x,_fmaxf(in.y,in.z));
    float rot_mat[3][3] = {{_sqrtf(6.0f)/3.0f, -_sqrtf(6.0f)/6.0f, -_sqrtf(6.0f)/6.0f}, {0.0, _sqrtf(2.0f)/2.0f,-_sqrtf(2.0f)/2.0f}, {_sqrtf(3.0f)/3.0f, _sqrtf(3.0f)/3.0f, _sqrtf(3.0f)/3.0f}};

    float3 rotated_color = mv_33_3(rot_mat, x);
    float theta = _atan2f(rotated_color.y, rotated_color.x) / (2.0 * PI);

    
    float3 spherical = make_float3(0.0, 0.0, 0.0);
	
	spherical.x = theta < 0.0 ? theta + 1.0 : theta;
	spherical.y = _sqrtf((rotated_color.x)*(rotated_color.x) + (rotated_color.y)*(rotated_color.y));
	spherical.y = _atan2f(spherical.y,rotated_color.z)/_atan2f(_sqrtf(2.0f),1.0f);
	spherical.z = norm;

    
    return spherical;
}

__DEVICE__ float3 Spherical_to_RGB(float3 in) {

	float3 copy = in;
	copy.x = copy.x + 0.5f;

	float chroma_gain1 = normalize_gain(in);
	float chroma_gain2 = normalize_gain(copy);

	in.y = _tanf(in.y*_atan2f(_sqrtf(2.0f),1.0f));
	in.y = in.y/_sqrtf(2);
	in.y = in.y/chroma_gain1;

	float norm_gain = (chroma_gain2+chroma_gain1*in.y)/chroma_gain2;

	in.z = in.z/norm_gain;
	in.y = in.y*chroma_gain1;

	float3 out = in;

	out.x = _cosf(in.x*2*PI)*in.y*in.z*_sqrtf(3)/(_sqrtf(2)/2);
	out.y = _sinf(in.x*2*PI)*in.y*in.z*_sqrtf(3)/(_sqrtf(2)/2);
	out.z = in.z*_sqrtf(3);

	float rot_mat[3][3] = {{_sqrtf(6.0f)/3.0f, 0.0, _sqrtf(3.0f)/3.0f}, {-_sqrtf(6.0f)/6.0f, _sqrtf(2.0f)/2.0f,_sqrtf(3.0f)/3.0f}, {-_sqrtf(6.0f)/6.0f, -_sqrtf(2.0f)/2.0f, _sqrtf(3.0f)/3.0f}};

    out = mv_33_3(rot_mat, out);


    return out;
}

__DEVICE__ float3 spherical_to_cone(float3 in) {

	float3 out = in;
	
	float chroma = in.y;
	float angle = (in.x)*2*PI;
	angle = angle - PI/6;

	chroma = chroma*_atan2f(_sqrtf(2.0f),1.0f);
	out.y = _tanf(chroma)/_sqrtf(2.0f);
	float chroma_gain = normalize_gain(in);

	out.y = out.y/chroma_gain;


    return out;
}

__DEVICE__ float3 RGB_to_Cone(float3 in) {

    float3 out = in;

    out = RGB_to_Spherical(in);
 	out = spherical_to_cone(out);

    return out;
}

__DEVICE__ float3 cone_to_spherical(float3 in) {

	float3 out = in;
	
	float chroma = in.y;
	float angle = (in.x)*2*PI;
	angle = angle - PI/6;

	chroma = chroma*_atan2f(_sqrtf(2.0f),1.0f);
	out.y = _tanf(chroma)/_sqrtf(2.0f);
	float chroma_gain = normalize_gain(in);

	out.y = out.y*chroma_gain;

    return out;
}

__DEVICE__ float3 Cone_to_RGB(float3 in) {

	float3 copy = in;
	copy.x = copy.x + 0.5f;

	float chroma_gain1 = normalize_gain(in);
	float chroma_gain2 = normalize_gain(copy);

	float norm_gain = (chroma_gain2+chroma_gain1*in.y)/chroma_gain2;

	in.z = in.z/norm_gain;
	in.y = in.y*chroma_gain1;

	float3 out = in;

	out.x = _cosf(in.x*2*PI)*in.y*in.z*_sqrtf(3)/(_sqrtf(2)/2);
	out.y = _sinf(in.x*2*PI)*in.y*in.z*_sqrtf(3)/(_sqrtf(2)/2);
	out.z = in.z*_sqrtf(3);

	float rot_mat[3][3] = {{_sqrtf(6.0f)/3.0f, 0.0, _sqrtf(3.0f)/3.0f}, {-_sqrtf(6.0f)/6.0f, _sqrtf(2.0f)/2.0f,_sqrtf(3.0f)/3.0f}, {-_sqrtf(6.0f)/6.0f, -_sqrtf(2.0f)/2.0f, _sqrtf(3.0f)/3.0f}};

    out = mv_33_3(rot_mat, out);


    return out;
}

__DEVICE__ float3 RGB_to_LCH(float3 XYZ) {
    const float X = XYZ.x;
    const float Y = XYZ.y;
    const float Z = XYZ.z;

    // CIE 1931 XYZ To LMS
    const float l = (X * 0.8189330101f) + (Y * 0.3618667424f) + (Z * -0.1288597137f);
    const float m = (X * 0.0329845436f) + (Y * 0.9293118715f) + (Z * 0.0361456387f);
    const float s = (X * 0.0482003018f) + (Y * 0.2643662691f) + (Z * 0.6338517070f);
        
    // LMS Non-Linearity 	
    const float l_prime = cbrtf(l,0.0f);	
    const float m_prime = cbrtf(m,0.0f);	
    const float s_prime = cbrtf(s,0.0f);

    // LMS Non-Linearity To OKLAB
    const float l_lab = (l_prime * 0.2104542553f) + (m_prime * 0.7936177850f) + (s_prime * -0.0040720468f);
    const float a_lab = (l_prime * 1.9779984951f) + (m_prime * -2.4285922050f) + (s_prime * 0.4505937099f);
    const float b_lab = (l_prime * 0.0259040371f) + (m_prime * 0.7827717662f) + (s_prime * -0.8086757660f);

    // OKLAB To LCH(ab)
    float pi = 3.14159265359f;

    float lch_l = l_lab;
    float lch_c = _sqrtf((a_lab * a_lab) + (b_lab * b_lab));
    float lch_h = _atan2f(b_lab, a_lab) * (180.f/pi);

    if (lch_h < 0.f) {
        lch_h = lch_h + 360.f;
    }

    return make_float3(lch_l, lch_c, lch_h);
}
	
__DEVICE__ float3 LCH_to_RGB(float3 lch) {
    // LCH(ab) To OKLAB 
    float pi = 3.14159265359f;

    const float lab_l = lch.x;
    const float lab_a = lch.y * _cosf((lch.z*(pi/180.f)));
    const float lab_b = lch.y * _sinf((lch.z* (pi/180.f)));

    // OKLAB To LMS Non-Linearity 
    const float l_prime = (lab_l * 1.00000000f) + (lab_a * 0.39633784f) + (lab_b * 0.21580376f);
    const float m_prime = (lab_l * 1.00000000f) + (lab_a * -0.10556135f) + (lab_b * -0.06385418f);
    const float s_prime = (lab_l * 1.00000000f) + (lab_a * -0.08948418f) + (lab_b * -1.29148555f);

    // LMS Non-Linearity To LMS
    const float l = _copysignf(_powf(fabs(l_prime),3), l_prime);
    const float m = _copysignf(_powf(fabs(m_prime),3), m_prime);
    const float s = _copysignf(_powf(fabs(s_prime),3), s_prime);

    // LMS To CIE 1931 XYZ  
    const float rxyz = (l * 1.2270138511f) + (m * -0.55779998065f) + (s * 0.2812561489f);
    const float gxyz = (l * -0.0405801784f) + (m * 1.1122568696f) + (s * -0.0716766786f);
    const float bxyz = (l * -0.0763812845f) + (m * -0.4214819784f) + (s * 1.5861632204f);

    return make_float3(rxyz, gxyz, bxyz);
}

__DEVICE__ float3 XYZ_to_OKLab(float3 XYZ, float offset, float scale) {
    const float X = XYZ.x;
    const float Y = XYZ.y;
    const float Z = XYZ.z;

    // CIE 1931 XYZ To LMS
    const float l = (X * 0.8189330101f) + (Y * 0.3618667424f) + (Z * -0.1288597137f);
    const float m = (X * 0.0329845436f) + (Y * 0.9293118715f) + (Z * 0.0361456387f);
    const float s = (X * 0.0482003018f) + (Y * 0.2643662691f) + (Z * 0.6338517070f);

    // LMS Non-Linearity
    const float l_prime = spowf(l, 1.0f / 3.0f);
    const float m_prime = spowf(m, 1.0f / 3.0f);
    const float s_prime = spowf(s, 1.0f / 3.0f);

    // LMS Non-Linearity To OKLAB
    const float L = (l_prime * 0.2104542553f) + (m_prime * 0.7936177850f) + (s_prime * -0.0040720468f);
    const float a = (l_prime * 1.9779984951f) + (m_prime * -2.4285922050f) + (s_prime * 0.4505937099f);
    const float b = (l_prime * 0.0259040371f) + (m_prime * 0.7827717662f) + (s_prime * -0.8086757660f);

    // scaling and offset
    return make_float3(L, a * scale + offset, b * scale + offset);
}
  
__DEVICE__ float3 OKLab_to_XYZ(float3 Lab, float offset, float scale) {
    // scaling and offset
    const float L = Lab.x;
    const float a = (Lab.y - offset) / scale;
    const float b = (Lab.z - offset) / scale;

    // OKLAB To LMS Non-Linearity
    const float l_prime = (L * 1.00000000f) + (a * 0.39633784f) + (b * 0.21580376f);
    const float m_prime = (L * 1.00000000f) + (a * -0.10556135f) + (b * -0.06385418f);
    const float s_prime = (L * 1.00000000f) + (a * -0.08948418f) + (b * -1.29148555f);

    // LMS Non-Linearity To LMS
    const float l = spowf(l_prime, 3.0f);
    const float m = spowf(m_prime, 3.0f);
    const float s = spowf(s_prime, 3.0f);

    // LMS To CIE 1931 XYZ
    const float X = (l * 1.2270138511f) + (m * -0.55779998065f) + (s * 0.2812561489f);
    const float Y = (l * -0.0405801784f) + (m * 1.1122568696f) + (s * -0.0716766786f);
    const float Z = (l * -0.0763812845f) + (m * -0.4214819784f) + (s * 1.5861632204f);

    return make_float3(X, Y, Z);
}



// ---------------------------------------------------------- convert functions


 __DEVICE__ float3 rgb_inset (float3 rgb) {
    const float r_inset = rgb.x * 0.8357302628472827f + rgb.y * 0.07575160430529301f + rgb.z * 0.08851819789301629f;
    const float g_inset = rgb.x * 0.07272987026297614f + rgb.y * 0.8387515418967071f + rgb.z * 0.08851798996797691f;
    const float b_inset = rgb.x * 0.07272966839689886f + rgb.y * 0.07575121559727113f + rgb.z * 0.8515177877383528f;
    return make_float3(r_inset, g_inset, b_inset);
     
}       

 __DEVICE__ float3 rgb_outset (float3 rgb) {
    const float r_outset = rgb.x * 1.215294430519138f + rgb.y * -0.09928130201704202f + rgb.z * -0.11601342100604005f;
    const float g_outset = rgb.x * -0.09532096746629887f + rgb.y * 1.2113347084396262f + rgb.z * -0.11601316464611539f;
    const float b_outset = rgb.x * -0.09532071196581424f + rgb.y * -0.09928081562487852f + rgb.z * 1.1946030611860257f;
    return make_float3(r_outset, g_outset, b_outset);
}

__DEVICE__ float3 convert_colorSpace_model(float3 in, int space_type, bool direction, int in_gamut) {
  float3 out = in, RGB, XYZ, Lab;


  // Input gamut conversion to D65 aligned XYZ (CAT: xyz scaling)
  float3x3 in_to_xyz;
  if (in_gamut == 0)         in_to_xyz = matrix_ap0_to_xyz;
  else if (in_gamut == 1)    in_to_xyz = matrix_ap1_to_xyz;
  else if (in_gamut == 2)    in_to_xyz = matrix_p3d65_to_xyz;
  else if (in_gamut == 3)    in_to_xyz = matrix_rec2020_to_xyz;
  else if (in_gamut == 4)    in_to_xyz = matrix_rec709_to_xyz;
  else if (in_gamut == 5)    in_to_xyz = matrix_arriwg_to_xyz;
  else if (in_gamut == 6)    in_to_xyz = matrix_redwg_to_xyz;
  else if (in_gamut == 7)    in_to_xyz = matrix_sonysgamut3;
  else if (in_gamut == 8)    in_to_xyz = matrix_blackmagicwg_to_xyz;
  else if (in_gamut == 9)    in_to_xyz = matrix_egamut_to_xyz;
  else if (in_gamut == 10)   in_to_xyz = matrix_davinciwg_to_xyz;
  const float3x3 xyz_to_in = inv_f33(in_to_xyz);


  float offset = 0.0f;
  float scale = 2.0f;


  if(space_type == 0) { return out; }// No conversion
  else if (space_type == 4) out = direction ? RGB_to_CHEN(out) : CHEN_to_RGB(out);
  else if (space_type == 2) out = direction ? RGB_to_HSV(out) : HSV_to_RGB(out);
  else if (space_type == 5) out = direction ? RGB_to_Reuleaux(out) : Reuleaux_to_RGB(out);
  else if (space_type == 6) out = direction ? RGB_to_Cylindrical(out) : Cylindrical_to_Rgb(out);
  else if (space_type == 3) out = direction ? RGB_to_HSP(out) : HSP_to_RGB(out);
  else if (space_type == 1) out = direction ? RGB_to_HSL(out) : HSL_to_RGB(out);
  else if (space_type == 8) out = direction ? RGB_to_Cone(out) : Cone_to_RGB(out);
  else if (space_type == 7) out = direction ? RGB_to_Spherical(out) : Spherical_to_RGB(out);

  // RGB to Lab-based models
  else if (space_type >= 9 && space_type <= 12) {
    if (direction) {
        RGB = rgb_inset(in);
        XYZ = mult_f3_f33(RGB, in_to_xyz);
        Lab = (space_type == 9) ? XYZ_to_CIELab(XYZ, offset, scale) :
            (space_type == 10) ? RGB_to_LCH(XYZ) :
            (space_type == 11) ? XYZ_to_OKLab(XYZ, offset, scale) :
                                XYZ_to_ProLab(XYZ, offset, scale);
        out = (space_type == 10) ? Lab : Lab_to_LCH(Lab);
      } else {
        Lab = (space_type == 10) ? in : LCH_to_Lab(in);
        XYZ = (space_type == 9) ? CIELab_to_XYZ(Lab, offset, scale) :
            (space_type == 10) ? LCH_to_RGB(Lab) :
            (space_type == 11) ? OKLab_to_XYZ(Lab, offset, scale) :
                                ProLab_to_XYZ(Lab, offset, scale);
        RGB = mult_f3_f33(XYZ, xyz_to_in);
        out = rgb_outset(RGB);
      }
  }

  return out;
}

//--------------------------------------------------------------- another functions

// https://www.desmos.com/calculator/4qnakiivnj
__DEVICE__ float cubic_chroma(float x, float m, float s) {
	float p = m < 0.0f ? s : 2.0f*s;
	float c0 = 1.0f - _fabs(m);
	float a0 = p*(c0 - 1.0f);
	float b0 = (1.0f - c0)*(p + 1.0f);
	if (m > 0.0f) 
		return x > 1.0f ? c0*(x - 1.0f) + 1.0f : x < 0.0f ? x : 1.0f - (1.0f - x)*(_powf(1.0f - x, p)*(a0*(1.0f - x) + b0) + c0);
	else 
		return x < 0.0f ? c0*x : x > 1.0f ? x : x*(_powf(x, p)*(a0*x + b0) + c0);
}


DEFINE_UI_PARAMS(SAT_GM, Green / Magenta, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.001)
DEFINE_UI_PARAMS(SAT_YB, Yellow / Blue, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.001)
DEFINE_UI_PARAMS(SAT_CR, Cyan / Red, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.001)

DEFINE_UI_PARAMS(SAT_SPACE_OVE, Saturation Space, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.0001)
DEFINE_UI_PARAMS(SAT_SPACE_OVE_ENABLE, Enable Saturation Space, DCTLUI_CHECK_BOX, 1)

DEFINE_UI_PARAMS(SAT_RGB_OVE, Saturation, DCTLUI_SLIDER_FLOAT, 0.0, -1.0, 1.0, 0.001)
DEFINE_UI_PARAMS(SAT_RGB_OVE_ENABLE, Enable Saturation, DCTLUI_CHECK_BOX, 1)

DEFINE_UI_PARAMS(SUBSAT_OVE, Subtractive Sat, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 1.0, 0.001)
DEFINE_UI_PARAMS(SUBSAT_OVE_ENABLE, Enable Subtractive Sat, DCTLUI_CHECK_BOX, 1)

DEFINE_UI_PARAMS(DESATCH_OVE, Luminance, DCTLUI_SLIDER_FLOAT, 0.0, -1.0, 0.0, 0.0001)
DEFINE_UI_PARAMS(DESATCH_OVE_ENABLE, Enable Luminance, DCTLUI_CHECK_BOX, 1)

DEFINE_UI_PARAMS(CHROMA_OVE, Chroma, DCTLUI_SLIDER_FLOAT, 0.0, -1.0, 1.0, 0.0001)
DEFINE_UI_PARAMS(CHROMA_OVE_ENABLE, Enable Chroma, DCTLUI_CHECK_BOX, 1)

DEFINE_UI_PARAMS(SPACE_TYPE, Space Type, DCTLUI_COMBO_BOX, 0, {none, hsl, hsv, hsp, chen, reuleaux, cylindrical, spherical, cone, cielab, lchab, oklab, prolab}, {None, HSL (Derived), HSV (Derived), HSP (Experimental), Chen (Experimental), Reuleaux (Experimental), Cylindrical (Experimental), Spherical (Experimental), Cone (Experimental), CIELab (Classic), LCHab (Classic), OKLab (Classic), ProLab (Experimental)})
DEFINE_UI_PARAMS(IN_GAMUT, Input Gamut, DCTLUI_COMBO_BOX, 10, {ap0, ap1, p3d65, rec2020, rec709, awg, rwg, sgamut3, blackmagicwg, egamut, davinciwg}, {ACES, ACEScg, P3D65, Rec.2020, Rec.709, Alexa Wide Gamut, Red Wide Gamut RGB, Sony SGamut3, Blackmagic Wide Gamut, Filmlight E - Gamut, DaVinci Wide Gamut})

DEFINE_UI_PARAMS(ZONE_SAT, Zone Saturation, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.001)
DEFINE_UI_PARAMS(ZONE_PIVOT, Zone Pivot, DCTLUI_SLIDER_FLOAT, 0.0, -1.0, 1.0, 0.001)
DEFINE_UI_PARAMS(SAT_ZONE_ENABLE, Enable Zone, DCTLUI_CHECK_BOX, 1)

// Tooltips
#if ((__RESOLVE_VER_MAJOR__ > 19)) || ((__RESOLVE_VER_MAJOR__ == 19) && (__RESOLVE_VER_MINOR__ >= 1))

DEFINE_UI_TOOLTIP(Green / Magenta, "Saturation of Magenta and Green colors only")
DEFINE_UI_TOOLTIP(Yellow / Blue, "Saturation of Yellow and Blue colors only")
DEFINE_UI_TOOLTIP(Cyan / Red, "Saturation of Cyan and Red colors only")

DEFINE_UI_TOOLTIP(Saturation Space, "Saturation Space for Space Type Selected")
DEFINE_UI_TOOLTIP(Enable Saturation Space, "Enable Saturation Space")

DEFINE_UI_TOOLTIP(Saturation, "Saturation Standard for RGB colors")
DEFINE_UI_TOOLTIP(Enable Saturation, "Enable Saturation Standard")

DEFINE_UI_TOOLTIP(Subtractive Sat, "Subtractive Saturation for Space Type Selected")
DEFINE_UI_TOOLTIP(Enable Subtractive Sat, "Enable Subtractive Saturation")

DEFINE_UI_TOOLTIP(Luminance, "Luminance for Space Type Selected")
DEFINE_UI_TOOLTIP(Enable Luminance, "Enable Luminance") 

DEFINE_UI_TOOLTIP(Chroma, "Chroma for Space Type Selected")
DEFINE_UI_TOOLTIP(Enable Chroma, "Enable Chroma")

DEFINE_UI_TOOLTIP(Zone Sat Low, "Zone Saturation for low values")
DEFINE_UI_TOOLTIP(Pivot Low, "Pivot for low values")
DEFINE_UI_TOOLTIP(Zone Sat High, "Zone Saturation for high values")
DEFINE_UI_TOOLTIP(Pivot High, "Pivot for high values")
DEFINE_UI_TOOLTIP(Enable Zone, "Enable Zone Saturation")

#endif


__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {

    float3 rgb, rgb_ove, lms, xyz, color_sapce;
    float hue, sat, val, SatGM, SatYB, SatCR;

    SatGM = SAT_GM, SatYB = SAT_YB, SatCR = SAT_CR;
    
    rgb = make_float3(p_R, p_G, p_B);
    rgb_ove = make_float3(p_R, p_G, p_B);

    // Convert RGB to grayscale (luminance)
    float luminance = 0.2126 * p_R + 0.7152 * p_G + 0.0722 * p_B;

    // Adjust saturation
    rgb_ove = luminance + (rgb_ove - luminance) * SAT_RGB_OVE;
    

    // Convert color space type
    color_sapce = convert_colorSpace_model(rgb, SPACE_TYPE , 1, IN_GAMUT);
    hue = color_sapce.x;
    sat = color_sapce.y;
    val = color_sapce.z;

    // Chroma
    if(CHROMA_OVE_ENABLE) {
        float mo = _powf(2.0f, -CHROMA_OVE);
        sat = cubic_chroma(sat, (1-mo), 2.0f);
    }

    // Value (deSatch)
    if (DESATCH_OVE_ENABLE) {
        float value_factor = DESATCH_OVE * sat + 1.0f;
        val *= value_factor;
    }

    // Calculate Saturation for each hue
    float2 sat_curve[N_POINTS] = {
        {5.0f / 6.0f - 1.0f, SatGM},  //MAG_SAT
        {0.0f,               SatCR},  //RED_SAT
        {1.0f / 6.0f,        SatYB},  //YEL_SAT
        {2.0f / 6.0f,        SatGM},  //GRN_SAT
        {3.0f / 6.0f,        SatCR},  //CYN_SAT
        {4.0f / 6.0f,        SatYB},  //BLU_SAT
        {5.0f / 6.0f,        SatGM},  //MAG_SAT
        {1.0f,               SatCR},  //RED_SAT
        {1.0f / 6.0f + 1.0f, SatYB}   //YEL_SAT
    };

    float sat_factor = interp_linear(sat_curve, N_POINTS, hue) * (SAT_SPACE_OVE + 0.5f);
    sat_factor = 1.0f / sat_factor;
    float sat_result = SAT_SPACE_OVE_ENABLE ? spow(sat, sat_factor) : sat;
    
    // Calculate Saturation for each hue for subtractive saturation
    float2 subSat_curve[5] = {
        {5.0f / 6.0f - 1.0f, 1.0f},  //MAG_SAT
        {1.0f / 6.0f,        1.0f},  //YEL_SAT
        {3.0f / 6.0f,        1.0f},  //CYN_SAT
        {5.0f / 6.0f,        1.0f},  //MAG_SAT
        {1.0f / 6.0f + 1.0f, 1.0f}   //YEL_SAT
    };

    float subSat_factor = interp_linear(subSat_curve, 5, hue) * (SUBSAT_OVE + 0.0f);
    subSat_factor = 1.0f / subSat_factor;
    float subSat_result = SUBSAT_OVE_ENABLE ? spow(sat, subSat_factor) : sat_result - sat_result;


    float result_all = sat_result + subSat_result;

    rgb = convert_colorSpace_model(make_float3(hue, result_all, val), SPACE_TYPE, 0, IN_GAMUT);
    

    if(SAT_RGB_OVE_ENABLE) {
        // Join RGB modified sat and luminance
        rgb = rgb + (rgb_ove - luminance);
    }
    
    
    const float3x3 xyz_to_lms = matrix_xyz_to_truelightlms;
    const float3x3 lms_to_xyz = inv_f33(matrix_xyz_to_truelightlms);

    // Input gamut conversion to D65 aligned XYZ (CAT: xyz scaling)
    float3x3 in_to_xyz;
    if (IN_GAMUT == ap0)                in_to_xyz = matrix_ap0_to_xyz;
    else if (IN_GAMUT == ap1)           in_to_xyz = matrix_ap1_to_xyz;
    else if (IN_GAMUT == p3d65)         in_to_xyz = matrix_p3d65_to_xyz;
    else if (IN_GAMUT == rec2020)       in_to_xyz = matrix_rec2020_to_xyz;
    else if (IN_GAMUT == rec709)        in_to_xyz = matrix_rec709_to_xyz;
    else if (IN_GAMUT == awg)           in_to_xyz = matrix_arriwg_to_xyz;
    else if (IN_GAMUT == rwg)           in_to_xyz = matrix_redwg_to_xyz;
    else if (IN_GAMUT == sgamut3)       in_to_xyz = matrix_sonysgamut3;
    else if (IN_GAMUT == blackmagicwg)  in_to_xyz = matrix_blackmagicwg_to_xyz;
    else if (IN_GAMUT == egamut)        in_to_xyz = matrix_egamut_to_xyz;
    else if (IN_GAMUT == davinciwg)     in_to_xyz = matrix_davinciwg_to_xyz;
    const float3x3 xyz_to_in = inv_f33(in_to_xyz);


    if(SAT_ZONE_ENABLE) {
        // Convert RGB to LMS space via XYZ
        xyz = mult_f3_f33(rgb, in_to_xyz);
        lms = mult_f3_f33(xyz, xyz_to_lms);
        lms /= catd65;

        // Calculate mean luminance
        float mean_lum = (lms.x + lms.y + lms.z) / 3.0f;
        
        // Calculate zone weight with pivot control
        // Pivot < 0: affects darker areas more
        // Pivot > 0: affects brighter areas more
        float zone_weight = _powf(mean_lum, 1.0f / (1.0f + ZONE_PIVOT));
        
        // Apply saturation adjustment with zone weighting
        // ZONE_SAT < 1: reduces saturation
        // ZONE_SAT > 1: increases saturation
        float3 adjusted_lms = mean_lum + (lms - mean_lum) * ZONE_SAT;
        lms = _mix(lms, adjusted_lms, zone_weight);

        // Convert back to RGB
        lms *= catd65;
        xyz = mult_f3_f33(lms, lms_to_xyz);
        rgb = mult_f3_f33(xyz, xyz_to_in);
    }

    return rgb;
}
